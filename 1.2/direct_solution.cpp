#include "direct_solution.h"

int T(MatrixTxT M, vector <pair<int,int>> V, int player) {
    /* Если в матрицы поле такое, что кто-то победил,
     * то дальше игра не продолжается и всего возможных
     * полей = 1 - само поле M, поданное не вход.
     * Аналогичные рассуждения про пустой вектор V,
     * ответсвенный за незанятые клетки поля
     * */
    if (M.Check().first != -1 || V.empty()) {
        return 1;
    }

    // Переменная, считающая число полей
    int ans = 0;

    /* Перебираем все позиции, в которые
     * игрок (player) может поставить
     * свой символ. Рекурсивно для этих полей
     * запускаем эту же функцию.
     * */
    for (int i = 0; i < V.size(); i++) {
        /* Здесь мы выбираем первый элемент из
         * вектора V и ставим на позицию, заданную
         * парой (p.first, p.second), символ игрока.
         * */
        pair<int,int> p = V[0];
        V.erase(V.begin(), V.begin() + 1);
        M.setElem(p.first, p.second, player);

        // Запускаем для нового поля функцию T
        ans += T(M,V,player%2+1);

        /* После того, как функция T отработала,
         * нам надо рассмотреть следующий возможный
         * ход, для этого мы возвращаем p в вектор,
         * но уже в конец, так что происходит "сдвиг"
         * всех значений и следующая итерация массива
         * возьмет новые координаты (p.first, p.second.
         *
         * Заодно подчищаем матрицу от того символа,
         * который ставили выше.
         * */
        V.push_back(p);
        M.setElem(p.first, p.second, 0);
    }

    /* +1, так как ans сейча равен числу возможных
     * полей, которые можно получить из этого, а
     * надо учесть еще само поле
     * */
    return ans+1;
}

int dsol () {
    // Создаем пустую матрицу
    MatrixTxT M = MatrixTxT();

    // Создаем вектор из всевозможных пар координат
    vector <pair<int,int>> V;
    for (int i = 0; i < MSIZE; i++) {
        for (int j = 0; j < MSIZE; j++) {
            V.push_back({i,j});
        }
    }

    // Запускаем тело нашего решения
    return T(M,V,1);
}
