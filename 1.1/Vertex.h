#ifndef INC_1_1_VERTEX_H
#define INC_1_1_VERTEX_H

#include <iostream>
#include <map>

using std::cout;
using std::endl;
using std::map;
using std::pair;

// Класс описывает вершину Бора
class Vertex {
public:
    /* Эта map содержит в себе переходы в Боре
     * как в ДКА: нет различий между переходами
     * по ребру и по суффиксной ссылке.
     * */
    map<char, Vertex*> * Next = new map<char, Vertex*>;

    /* Изначально этот параметр отвечает за то,
     * является ли наша вершина концом шаблонной
     * строки. Однако в силу поставленной задачи
     * я немного изменил ее предназначение: и теперь
     * она выявляет, есть ли среди шаблонов хотя
     * бы один, который является суффиксом строки,
     * соответствующей вершине.
     *
     * Пример:
     *
     *       a-> (1) -b-> (2)
     *      /
     * Root
     *      \
     *       d-> (3) -a-> (4) -b-> (5) -c-> (6)
     *
     * Изначально вершина 5 не является листом,
     * но так как вершина 2 является листом и среди
     * суффиксов строки "dab" есть "ab", соответствующий
     * вершине 2, то впоследствии вершина 5 тоже получит
     * значение Leaf = true.
     * */
    bool Leaf = false;

    /* Чтобы несколько раз не нужно было
     * проверять условие, описанное выше,
     * то была введена эта переменная, которая
     * становится равной true, если является
     * листом или если в какой-то момент
     * использовалась функция SetLeaf (см.
     * описание Tree), которая "прошлась"
     * по суффиксам и проверила, есть ли среди
     * них шаблонные строки.
     *
     * P.s. у этой переменной не полный функционал,
     * так как если из Бора удалять или добавлять
     * шаблонные строки уже после SetLeaf, то
     * невозможно отделить вершины, которые являются
     * концами шаблонных строк от вершин, которые
     * является концами строк, среди суффиксов
     * которых есть шаблонные строки.
     *
     * Чтобы решить эту проблему, можно добавить
     * новую переменную, чтобы отделить эти два
     * понятия, но в поставленной задаче это не
     * влияло на решение, так что такое расширение
     * кода только занимало бы больше памяти.
     * */
    bool SetLeaf = false;

    // Указатель на родителя вершины
    Vertex * Parent;

    // Символ перехода из родительской вершины в this
    char Pch;

    /* Суффиксная ссылка, которая инициализируется
     * лениво в процессе работы программы
     * */
    Vertex * Link = nullptr;

    /* В процессе отладки эта функция требовалась,
     * чтобы распечатывать Бор
     * */
    void Print(int depth){
        for(int i = 0; i < depth; i++) {
            cout << "-";
        }
        cout << Pch << " (Leaf = " << Leaf << ")" << endl;
        for(auto it = Next->begin(); it != Next->end(); it++) {
            it->second->Print(depth+1);
        }
    }

    Vertex(): Leaf (false), Parent(nullptr), Pch(), Link(nullptr) {}
    Vertex(Vertex*_Parent, char _Pch) : Leaf (false),
        Parent(_Parent), Pch(_Pch) {}

    ~Vertex(){
        delete(Next);
        delete(Parent);
        delete(Link);

        for (auto it = Next->begin(); it != Next->end(); it++) {
            it->second->~Vertex();
        }
    }
};
#endif //INC_1_1_VERTEX_H
